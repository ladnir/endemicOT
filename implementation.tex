\section{Implementation}\label{sec:impl}

We give a detailed description of how to instantiate the OT protocols based on Diffie-Hellman key exchange under tigther security loss and based on Kyber in \iffullversion\appendixref{sec:inst}\fi. We implement and benchmark the optimized DH based \iffullversion(\appendixref{sec:optOT})\fi and the Kyber based protocol along with five implementations of our OT extension protocols \iffullversion\else(details are described in the full version)\fi. See \cite{libOTe} for source code. We then compare these two several other implementation including the Chou \& Orlandi \cite{LC:ChoOrl15} and Naor \& Pinkas \cite{SODA:NaoPin01} OT protocols and the chosen string variant of Keller, Orsini \& Scholl \cite{C:KelOrsSch15}.  All protocols are in the random oracle model.

All protocols are implemented 
%in the libOTe framework\cite{libOTe} which uses 
using the elliptic curve implementation of Relic Took-kit\cite{relic} and the assembly based curve25519 of \cite{LC:ChoOrl15,simplest}. For the OT protocol based on Kyber we adapt the \cite{NISTPQC-R1:CRYSTALS-KYBER17} key exchange implementation. For our protocol we instantiate the Random Oracle using Blake2 or the hashing to curve implementation of \cite{relic} and the Ideal Cipher using AES.

We perform experiments on a multi-core Intel Xeon processor at 2.7GHz and 256GB of RAM. Each party is given a single thread to execute on. The parties communicate over a network loopback device. We consider two settings, LAN where the parties have a 10Gbp connection and sub millisecond latency and a WAN setting where an artificial latency of 50 ms and throughput of 100Mbps is imposed on the loopback device. We consider computation security parameter $\kappa=128$ and statistical security of $\lambda=40$.  Some of the OT protocols take advantage of code written in assembly which can significantly outperform the other c++ implementations.
\newcommand{\mr}[2]{\multirow{#1}{*}{#2}}

\begin{figure*}[t!]\centering
	\iffullversion
	\scriptsize\fi
	\begin{tabular}{|c||c|c|c || r | r|  r | r |r |r|r |r|}
		\hline
		     \mr{3}{Protocol}       &                  \mr{3}{Security$^\dag$}                   & \mr{3}{Rounds} & \mr{3}{ASM} &                           \multicolumn{8}{c|}{$m$}                            \\
		                            &                                                     &                &             & 1      & 32     & 128     & 512     & 1       & 32      &      128 & 512      \\ \cline{5-12}
		                            &                                                     &                &             &      \multicolumn{4}{c|}{LAN}       &        \multicolumn{4}{c|}{WAN}         \\ \hline\hline
		\mr{2}{ \cite{LC:ChoOrl15}} &     \mr{2}{GapDH, RO$\rightarrow$ ``Rand. OT"}      & \mr{2}{   2 }  &     No      & 5      & 70     & 230     & 662     & 106     & 179     &      301 & 581      \\ \cline{4-12}
		                            &                                                     &                &     Yes     & 2      & {\bf6} & {\bf18} & {\bf64} & 104     & 115     &      210 & {272}    \\ \hline
		   \cite{SODA:NaoPin01}     &           DDH, RO $\rightarrow\OOT^\send$           &       3        &     No      & 5      & 67     & 203     & 573     & 155     & 185     &      304 & 593      \\ \hline
		       \mr{3}{ This}        &       \mr{2}{  IDDH, RO $\rightarrow\OOT^\E$}        &   \mr{2}{ 1}   &     No      & 3      & 46     & 148     & 480     & {54}    & 135     &      240 & 550      \\ \cline{4-12}
		                            &                                                     &                &    Some     & {\bf1} & 11     & 28      & 111     & {\bf53} & {\bf75} & {\bf110} & {\bf225} \\ \cline{2-12}
		                            & LWE, RO $\rightarrow\OOT^\send$ or $\OOT^{\send u}$ &       2        &     Yes     & {\bf1} & {\bf6} & {24}    & { 105}  & 101     & {108}   &    {154} & 481      \\ \hline
	\end{tabular}
	\caption{ \label{fig:baseTimes}Running times in milliseconds of our OT protocols and \cite{LC:ChoOrl15,SODA:NaoPin01}. ASM indicates if the implementation was written in assembly (better performance). $^\dag$We emphasize that both, \cite{SODA:NaoPin01} and \cite{LC:ChoOrl15} do not give full simulation based malicious security, but only weaker security guarantees.}	
\end{figure*}



We begin with the performance results for our OT protocols. These are detailed in \figureref{fig:baseTimes}. Interestingly, our two protocols are each more efficient than the other depending on the network setting. The Kyber based protocol protocol is most efficient in the LAN setting. This is due to the highly efficient operations which essentially comprise of linear algebra. However, the public keys and encryptions that are send in the Kyber based protocol are 40 times larger than the DH based OT. For example, a single OT using Kyber requires a total of 5,934 bytes while the DH protocol requires 145 bytes. In the LAN setting this added communication has little impact. To perform 128 OT the Kyber implementation requires 24 milliseconds while our DH based approach takes 25 milliseconds (when using an assembly based implementation). We note that one would rarely perform a different number of OTs than 128 which are used as a seed for OT extension.

In the WAN setting the decreased round complexity and communication of the DH approach allows it to achieve the smallest running times. To perform 128 OTs the DH protocol requires 130 milliseconds while the Kyber protocol requires 154 milliseconds. However, this increased performance comes at the expense of only achieving $\OOT^\E$-security. 

We also compare against the protocol of \cite{LC:ChoOrl15} and \cite{SODA:NaoPin01}. In the LAN setting the fast protocol is that of  \cite{LC:ChoOrl15} which requires each party to performance an amortized three exponentiation per OT while our DH protocol requires four. Both require five in the worst case. However, the \cite{LC:ChoOrl15} approach suffers from a technical issue in the proof where the input of the receiver can not be extracted at the appropriate time. As a result, to compose this protocol with OT extension requires additional computation and rounds of communication which we do not consider in our comparison, e.g. see \cite[Appendix A]{SP:DKLS18}. In addition, our hash to group implementation which takes up the majority of the running time difference is \emph{not} written in assembly. We suspect the gap between us and \cite{LC:ChoOrl15} narrow significantly if ours was fully optimized. We also note that our protocol achieve full endemic security in just one round or sender chosen message in two rounds. 

Regardless, in the WAN setting with 128 OT our protocols achieve the best performance of 110ms (DH) and 154ms (Kyber) compared to 210ms by  \cite{LC:ChoOrl15}. To achieve simulation bases security, at least one more round of communication is requires which would bring their time to at least 260ms, a $2.3\times$ increase compared to our protocol. To perform a single OT, our DDH protocol requires 145 bytes of communication, our Kyber protocol requires 5,934 bytes, \cite{LC:ChoOrl15} requires  the least with 112 bytes and \cite{SODA:NaoPin01} requires 165 bytes.


\begin{figure*}[t!]\centering
	\iffullversion
	\scriptsize
	\fi
	\begin{tabular}{|l||c|c|c || r | r|  r |r |r|r |r|r|}
		\hline
		\mr{3}{Protocol}  &         \mr{3}{Security}          & \mr{3}{Total} & \mr{3}{$n$} &                                     \multicolumn{8}{c|}{$m$}                                     \\
		                           &                                            &                        &                      & $2^{12}$ & $2^{16}$ & $2^{20}$ & $2^{24}$  & $2^{12}$  &  $2^{16}$ & $2^{20}$    &      $2^{24}$ \\ \cline{5-12}
		                           &                                            &         Rounds         &                      &          \multicolumn{4}{c|}{LAN}          &              \multicolumn{4}{c|}{WAN}               \\ \hline\hline
		$\Pi^{\textsf{ext-U}}$   &  $\OOT^{\send u},$RO $\rightarrow\OOT^\U$  &           4            &       $2^{76}$       & 20       & 151      & 1,612    & 24,060    & 345       &       833 & 7,003       &       103,481 \\ \hline\hline
		\cite{C:KelOrsSch15}       & $\OOT^{\send},$RO $\rightarrow\OOT^\send$  &           5            &          2           & 28       & 84       & 640      & 8,361     & 865       &      1769 & 7,504       &        85,077 \\ \hline
		$\Pi^{\textsf{ext-R}}$    & $\OOT^{\send u},$RO $\rightarrow\OOT^\rec$ &        {\bf 2}         &          2           & 14       & 76       & 610      & 8,224     & 406       &       700 & 2,488       &        32,315 \\ \hline
		$\Pi^{\textsf{ext-U}}$   &  $\OOT^{\send u},$RO $\rightarrow\OOT^\U$  &           4            &          2           & 18       & 70       & 547      & 7,429     & 407       &       708 & 2,666       &        32,856 \\ \hline\hline
		$\Pi^{\textsf{ext-R}\pi}$ &  $\OOT^{\U u},$IC $\rightarrow\OOT^\rec$   &           3            &          2           & 14       & 22       & 174      & 1,158     & {\bf 300} & {\bf 530} & {\bf 2,097} & {\bf  25,701} \\ \hline
		$\Pi^{\textsf{ext-U}\pi}$ &   $\OOT^{\U u},$IC $\rightarrow\OOT^\U$    &           5            &          2           & {\bf6}   & {\bf24}  & {\bf101} & {\bf 720} & {395}     &    { 645} & {2,128}     &      {26,256} \\ \hline
	\end{tabular}
	\caption{ \label{fig:extTimes}Running times in milliseconds of our 1-out-of-$n$ OT extension protocols and \cite{C:KelOrsSch15} as implemented by \cite{libOTe}. Base OT running times are \emph{not} included. RO indicates that a random oracle is used to has while IC \emph{additionally} indicates an ideal cipher was used in the Davie-Meyer compression function, see \sectionref{sec:extSec}. Rounds includes the rounds required for base OTs. }	
\end{figure*}



We now turn our attention to the  OT extension performance result as shown in \figureref{fig:extTimes}. We compare our protocols to the fastest implementation \cite{C:KelOrsSch15,libOTe}. In particular, we update the \cite{libOTe} implementation of \cite{C:KelOrsSch15} to allow the sender to specify the output messages and include the index $i$ in the call to the random oracle $\H$, as specified by \cite{C:KelOrsSch15}. . We implement five variants of our proposals where the output strings are sampled by the protocol (or possibly a malicious party). The 1-out-of-2 $\Pi^{\textsf{ext-R}},\Pi^{\textsf{ext-R}\pi}$ protocols in the random oracle and ideal cipher model require 2 and 3 rounds of communication, respectively, and achieves $\OOT^\rec$-security. To reduce the rounds we apply the Fiat-Shamir transformation \cite{C:FiaSha86} to the sigma protocol of \cite{C:KelOrsSch15} for \stepref{step:consistency}. We also implement the $\Pi^{\textsf{ext-U}}$ and $\Pi^{\textsf{ext-\U}\pi}$ which both achieve $\OOT^\U$-security. 

In the LAN setting where communication and round complexity has little impact the fastest protocol is our $\Pi^{\textsf{ext-\U}\pi}$ protocol which achieves our strongest security notion. The performance of this approach derives from the exclusive use of AES in the protocol which has extremely fast hardware support. For example, $\Pi^{\textsf{ext-\U}\pi}$ is $10\times$ faster compared to the $\Pi^{\textsf{ext-U}}$ protocol which achieves the same $\OOT^\U$-security in the random oracle model. The next fastest protocol is $\Pi^{\textsf{ext-R}\pi}$ which achieves $\OOT^\rec$-security in the ideal cipher model. This protocol only requires 3 rounds of communication which allows it to be the most efficient in the WAN setting. However, the improved round complexity requires hashing the transcript of the protocol which decrease the running time in the LAN setting compared to $\Pi^{\textsf{ext-U}\pi}$.

In the random oracle model we implement the $\Pi^{\textsf{ext-R}}$ protocol which only requires 2 rounds of communication, including the base OTs. In particular, the OT extension sender sends the first base OT message and the receiver sends the second base OT message, the extension matrix $U$ and Fiat-Shamir proof of consistency. One short coming of this approach is that $\OOT^\rec$-security is achieved. However, we argue that this level of security could be sufficient for special purpose protocols which require both high performance and low round complexity. We also implement the $\Pi^{\textsf{ext-U}}$ protocol which requires two more rounds and does not apply the Fiat-Shamir transformation which allows improved performance in the LAN setting at the expense of worse performance in the WAN setting.  This protocol is also implemented for 1-out-of-$2^{76}$ OT where the sender computes three of the OT strings. 

For a point of comparison we benchmark the \cite{C:KelOrsSch15} protocol and find that our protocols are between 3 and 8 times more efficient, depending on the network setting. Our performance improvements stem from the use of of the Ideal Cipher model (AES) and that fact that our protocols output random strings where as the secure version of \cite{C:KelOrsSch15} requires the sender to send encrypted strings. This effectively triples the communication overhead and adds an additional round to the protocol. In particular, all of our extension protocols require an amortized $\kappa$ bits of communication per 1-out-of-2 OT while \cite{C:KelOrsSch15} requires $3\kappa$.